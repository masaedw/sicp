(load "./2.8.scm")

(define (mul-interval2 x y)
  (let ((ux (upper-bound x))
        (lx (lower-bound x))
        (uy (upper-bound y))
        (ly (lower-bound y)))
    (cond ((< 0 lx)
           (cond ((< 0 ly)
                  (make-interval (* lx ly) (* ux uy)))
                 ((< uy 0)
                  (make-interval (* ux ly) (* lx uy)))
                 (else
                  (make-interval (* ux ly) (* ux uy)))))
          ((< ux 0)
           (cond ((< 0 ly)
                  (make-interval (* lx uy) (* ux ly)))
                 ((< uy 0)
                  (make-interval (* ux uy) (* lx ly)))
                 (else
                  (make-interval (* lx uy) (* lx ly)))))
          (else
           (cond ((< 0 ly)
                  (make-interval (* lx uy) (* ux uy)))
                 ((< uy 0)
                  (make-interval (* ux ly) (* lx ly)))
                 (else
                  (let ((p1 (* lx ly))
                        (p2 (* lx uy))
                        (p3 (* ux ly))
                        (p4 (* ux uy)))
                    (make-interval (min p1 p2 p3 p4)
                                   (max p1 p2 p3 p4)))))))))

(define (eq-interval x y)
  (and (= (lower-bound x)
          (lower-bound y))
       (= (upper-bound x)
          (upper-bound y))))

(define (test x y)
  (let ((o (mul-interval x y))
        (m (mul-interval2 x y)))
    (if (eq-interval o m)
        (format "OK ~a ~a => ~a" x y o)
        (format "!! ~a ~a => ~a ~a" x y o m))))

(define (main args)
  (let ((a (make-interval 2 3))
        (b (make-interval -1 1))
        (c (make-interval -3 -2)))
    (format #t "a a ~a\n" (test a a))
    (format #t "a b ~a\n" (test a b))
    (format #t "a c ~a\n" (test a c))
    (format #t "b a ~a\n" (test b a))
    (format #t "b b ~a\n" (test b b))
    (format #t "b c ~a\n" (test b c))
    (format #t "c a ~a\n" (test c a))
    (format #t "c b ~a\n" (test c b))
    (format #t "c c ~a\n" (test c c))))

(define mul-interval mul-interval2)